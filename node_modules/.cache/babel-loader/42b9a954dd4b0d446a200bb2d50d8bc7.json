{"ast":null,"code":"'use strict';\n\nvar dsv = require('d3-dsv'),\n    sexagesimal = require('@mapbox/sexagesimal');\n\nvar latRegex = /(Lat)(itude)?/gi,\n    lonRegex = /(L)(on|ng)(gitude)?/i;\n\nfunction guessHeader(row, regexp) {\n  var name, match, score;\n\n  for (var f in row) {\n    match = f.match(regexp);\n\n    if (match && (!name || match[0].length / f.length > score)) {\n      score = match[0].length / f.length;\n      name = f;\n    }\n  }\n\n  return name;\n}\n\nfunction guessLatHeader(row) {\n  return guessHeader(row, latRegex);\n}\n\nfunction guessLonHeader(row) {\n  return guessHeader(row, lonRegex);\n}\n\nfunction isLat(f) {\n  return !!f.match(latRegex);\n}\n\nfunction isLon(f) {\n  return !!f.match(lonRegex);\n}\n\nfunction keyCount(o) {\n  return typeof o == 'object' ? Object.keys(o).length : 0;\n}\n\nfunction autoDelimiter(x) {\n  var delimiters = [',', ';', '\\t', '|'];\n  var results = [];\n  delimiters.forEach(function (delimiter) {\n    var res = dsv.dsvFormat(delimiter).parse(x);\n\n    if (res.length >= 1) {\n      var count = keyCount(res[0]);\n\n      for (var i = 0; i < res.length; i++) {\n        if (keyCount(res[i]) !== count) return;\n      }\n\n      results.push({\n        delimiter: delimiter,\n        arity: Object.keys(res[0]).length\n      });\n    }\n  });\n\n  if (results.length) {\n    return results.sort(function (a, b) {\n      return b.arity - a.arity;\n    })[0].delimiter;\n  } else {\n    return null;\n  }\n}\n/**\n * Silly stopgap for dsv to d3-dsv upgrade\n *\n * @param {Array} x dsv output\n * @returns {Array} array without columns member\n */\n\n\nfunction deleteColumns(x) {\n  delete x.columns;\n  return x;\n}\n\nfunction auto(x) {\n  var delimiter = autoDelimiter(x);\n  if (!delimiter) return null;\n  return deleteColumns(dsv.dsvFormat(delimiter).parse(x));\n}\n\nfunction csv2geojson(x, options, callback) {\n  if (!callback) {\n    callback = options;\n    options = {};\n  }\n\n  options.delimiter = options.delimiter || ',';\n  var latfield = options.latfield || '',\n      lonfield = options.lonfield || '',\n      crs = options.crs || '';\n  var features = [],\n      featurecollection = {\n    type: 'FeatureCollection',\n    features: features\n  };\n\n  if (crs !== '') {\n    featurecollection.crs = {\n      type: 'name',\n      properties: {\n        name: crs\n      }\n    };\n  }\n\n  if (options.delimiter === 'auto' && typeof x == 'string') {\n    options.delimiter = autoDelimiter(x);\n\n    if (!options.delimiter) {\n      callback({\n        type: 'Error',\n        message: 'Could not autodetect delimiter'\n      });\n      return;\n    }\n  }\n\n  var numericFields = options.numericFields ? options.numericFields.split(',') : null;\n  var parsed = typeof x == 'string' ? dsv.dsvFormat(options.delimiter).parse(x, function (d) {\n    if (numericFields) {\n      for (var key in d) {\n        if (numericFields.includes(key)) {\n          d[key] = +d[key];\n        }\n      }\n    }\n\n    return d;\n  }) : x;\n\n  if (!parsed.length) {\n    callback(null, featurecollection);\n    return;\n  }\n\n  var errors = [];\n  var i;\n  if (!latfield) latfield = guessLatHeader(parsed[0]);\n  if (!lonfield) lonfield = guessLonHeader(parsed[0]);\n  var noGeometry = !latfield || !lonfield;\n\n  if (noGeometry) {\n    for (i = 0; i < parsed.length; i++) {\n      features.push({\n        type: 'Feature',\n        properties: parsed[i],\n        geometry: null\n      });\n    }\n\n    callback(errors.length ? errors : null, featurecollection);\n    return;\n  }\n\n  for (i = 0; i < parsed.length; i++) {\n    if (parsed[i][lonfield] !== undefined && parsed[i][latfield] !== undefined) {\n      var lonk = parsed[i][lonfield],\n          latk = parsed[i][latfield],\n          lonf,\n          latf,\n          a;\n      a = sexagesimal(lonk, 'EW');\n      if (a) lonk = a;\n      a = sexagesimal(latk, 'NS');\n      if (a) latk = a;\n      lonf = parseFloat(lonk);\n      latf = parseFloat(latk);\n\n      if (isNaN(lonf) || isNaN(latf)) {\n        errors.push({\n          message: 'A row contained an invalid value for latitude or longitude',\n          row: parsed[i],\n          index: i\n        });\n      } else {\n        if (!options.includeLatLon) {\n          delete parsed[i][lonfield];\n          delete parsed[i][latfield];\n        }\n\n        features.push({\n          type: 'Feature',\n          properties: parsed[i],\n          geometry: {\n            type: 'Point',\n            coordinates: [parseFloat(lonf), parseFloat(latf)]\n          }\n        });\n      }\n    }\n  }\n\n  callback(errors.length ? errors : null, featurecollection);\n}\n\nfunction toLine(gj) {\n  var features = gj.features;\n  var line = {\n    type: 'Feature',\n    geometry: {\n      type: 'LineString',\n      coordinates: []\n    }\n  };\n\n  for (var i = 0; i < features.length; i++) {\n    line.geometry.coordinates.push(features[i].geometry.coordinates);\n  }\n\n  line.properties = features.reduce(function (aggregatedProperties, newFeature) {\n    for (var key in newFeature.properties) {\n      if (!aggregatedProperties[key]) {\n        aggregatedProperties[key] = [];\n      }\n\n      aggregatedProperties[key].push(newFeature.properties[key]);\n    }\n\n    return aggregatedProperties;\n  }, {});\n  return {\n    type: 'FeatureCollection',\n    features: [line]\n  };\n}\n\nfunction toPolygon(gj) {\n  var features = gj.features;\n  var poly = {\n    type: 'Feature',\n    geometry: {\n      type: 'Polygon',\n      coordinates: [[]]\n    }\n  };\n\n  for (var i = 0; i < features.length; i++) {\n    poly.geometry.coordinates[0].push(features[i].geometry.coordinates);\n  }\n\n  poly.properties = features.reduce(function (aggregatedProperties, newFeature) {\n    for (var key in newFeature.properties) {\n      if (!aggregatedProperties[key]) {\n        aggregatedProperties[key] = [];\n      }\n\n      aggregatedProperties[key].push(newFeature.properties[key]);\n    }\n\n    return aggregatedProperties;\n  }, {});\n  return {\n    type: 'FeatureCollection',\n    features: [poly]\n  };\n}\n\nmodule.exports = {\n  isLon: isLon,\n  isLat: isLat,\n  guessLatHeader: guessLatHeader,\n  guessLonHeader: guessLonHeader,\n  csv: dsv.csvParse,\n  tsv: dsv.tsvParse,\n  dsv: dsv,\n  auto: auto,\n  csv2geojson: csv2geojson,\n  toLine: toLine,\n  toPolygon: toPolygon\n};","map":{"version":3,"sources":["C:/mapboxAndReact/node_modules/csv2geojson/index.js"],"names":["dsv","require","sexagesimal","latRegex","lonRegex","guessHeader","row","regexp","name","match","score","f","length","guessLatHeader","guessLonHeader","isLat","isLon","keyCount","o","Object","keys","autoDelimiter","x","delimiters","results","forEach","delimiter","res","dsvFormat","parse","count","i","push","arity","sort","a","b","deleteColumns","columns","auto","csv2geojson","options","callback","latfield","lonfield","crs","features","featurecollection","type","properties","message","numericFields","split","parsed","d","key","includes","errors","noGeometry","geometry","undefined","lonk","latk","lonf","latf","parseFloat","isNaN","index","includeLatLon","coordinates","toLine","gj","line","reduce","aggregatedProperties","newFeature","toPolygon","poly","module","exports","csv","csvParse","tsv","tsvParse"],"mappings":"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","sourcesContent":["'use strict';\n\nvar dsv = require('d3-dsv'),\n    sexagesimal = require('@mapbox/sexagesimal');\n\nvar latRegex = /(Lat)(itude)?/gi,\n    lonRegex = /(L)(on|ng)(gitude)?/i;\n\nfunction guessHeader(row, regexp) {\n    var name, match, score;\n    for (var f in row) {\n        match = f.match(regexp);\n        if (match && (!name || match[0].length / f.length > score)) {\n            score = match[0].length / f.length;\n            name = f;\n        }\n    }\n    return name;\n}\n\nfunction guessLatHeader(row) { return guessHeader(row, latRegex); }\nfunction guessLonHeader(row) { return guessHeader(row, lonRegex); }\n\nfunction isLat(f) { return !!f.match(latRegex); }\nfunction isLon(f) { return !!f.match(lonRegex); }\n\nfunction keyCount(o) {\n    return (typeof o == 'object') ? Object.keys(o).length : 0;\n}\n\nfunction autoDelimiter(x) {\n    var delimiters = [',', ';', '\\t', '|'];\n    var results = [];\n\n    delimiters.forEach(function (delimiter) {\n        var res = dsv.dsvFormat(delimiter).parse(x);\n        if (res.length >= 1) {\n            var count = keyCount(res[0]);\n            for (var i = 0; i < res.length; i++) {\n                if (keyCount(res[i]) !== count) return;\n            }\n            results.push({\n                delimiter: delimiter,\n                arity: Object.keys(res[0]).length,\n            });\n        }\n    });\n\n    if (results.length) {\n        return results.sort(function (a, b) {\n            return b.arity - a.arity;\n        })[0].delimiter;\n    } else {\n        return null;\n    }\n}\n\n/**\n * Silly stopgap for dsv to d3-dsv upgrade\n *\n * @param {Array} x dsv output\n * @returns {Array} array without columns member\n */\nfunction deleteColumns(x) {\n    delete x.columns;\n    return x;\n}\n\nfunction auto(x) {\n    var delimiter = autoDelimiter(x);\n    if (!delimiter) return null;\n    return deleteColumns(dsv.dsvFormat(delimiter).parse(x));\n}\n\nfunction csv2geojson(x, options, callback) {\n\n    if (!callback) {\n        callback = options;\n        options = {};\n    }\n\n    options.delimiter = options.delimiter || ',';\n\n    var latfield = options.latfield || '',\n        lonfield = options.lonfield || '',\n        crs = options.crs || '';\n\n    var features = [],\n        featurecollection = {type: 'FeatureCollection', features: features};\n\n    if (crs !== '') {\n        featurecollection.crs = {type: 'name', properties: {name: crs}};\n    }\n\n    if (options.delimiter === 'auto' && typeof x == 'string') {\n        options.delimiter = autoDelimiter(x);\n        if (!options.delimiter) {\n            callback({\n                type: 'Error',\n                message: 'Could not autodetect delimiter'\n            });\n            return;\n        }\n    }\n\n    var numericFields = options.numericFields ? options.numericFields.split(',') : null;\n\n    var parsed = (typeof x == 'string') ?\n        dsv.dsvFormat(options.delimiter).parse(x, function (d) {\n            if (numericFields) {\n                for (var key in d) {\n                    if (numericFields.includes(key)) {\n                        d[key] = +d[key];\n                    }\n                }\n            }\n            return d;\n        }) : x;\n\n    if (!parsed.length) {\n        callback(null, featurecollection);\n        return;\n    }\n\n    var errors = [];\n    var i;\n\n\n    if (!latfield) latfield = guessLatHeader(parsed[0]);\n    if (!lonfield) lonfield = guessLonHeader(parsed[0]);\n    var noGeometry = (!latfield || !lonfield);\n\n    if (noGeometry) {\n        for (i = 0; i < parsed.length; i++) {\n            features.push({\n                type: 'Feature',\n                properties: parsed[i],\n                geometry: null\n            });\n        }\n        callback(errors.length ? errors : null, featurecollection);\n        return;\n    }\n\n    for (i = 0; i < parsed.length; i++) {\n        if (parsed[i][lonfield] !== undefined &&\n            parsed[i][latfield] !== undefined) {\n\n            var lonk = parsed[i][lonfield],\n                latk = parsed[i][latfield],\n                lonf, latf,\n                a;\n\n            a = sexagesimal(lonk, 'EW');\n            if (a) lonk = a;\n            a = sexagesimal(latk, 'NS');\n            if (a) latk = a;\n\n            lonf = parseFloat(lonk);\n            latf = parseFloat(latk);\n\n            if (isNaN(lonf) ||\n                isNaN(latf)) {\n                errors.push({\n                    message: 'A row contained an invalid value for latitude or longitude',\n                    row: parsed[i],\n                    index: i\n                });\n            } else {\n                if (!options.includeLatLon) {\n                    delete parsed[i][lonfield];\n                    delete parsed[i][latfield];\n                }\n\n                features.push({\n                    type: 'Feature',\n                    properties: parsed[i],\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [\n                            parseFloat(lonf),\n                            parseFloat(latf)\n                        ]\n                    }\n                });\n            }\n        }\n    }\n\n    callback(errors.length ? errors : null, featurecollection);\n}\n\nfunction toLine(gj) {\n    var features = gj.features;\n    var line = {\n        type: 'Feature',\n        geometry: {\n            type: 'LineString',\n            coordinates: []\n        }\n    };\n    for (var i = 0; i < features.length; i++) {\n        line.geometry.coordinates.push(features[i].geometry.coordinates);\n    }\n    line.properties = features.reduce(function (aggregatedProperties, newFeature) {\n        for (var key in newFeature.properties) {\n            if (!aggregatedProperties[key]) {\n                aggregatedProperties[key] = [];\n            }\n            aggregatedProperties[key].push(newFeature.properties[key]);\n        }\n        return aggregatedProperties;\n    }, {});\n    return {\n        type: 'FeatureCollection',\n        features: [line]\n    };\n}\n\nfunction toPolygon(gj) {\n    var features = gj.features;\n    var poly = {\n        type: 'Feature',\n        geometry: {\n            type: 'Polygon',\n            coordinates: [[]]\n        }\n    };\n    for (var i = 0; i < features.length; i++) {\n        poly.geometry.coordinates[0].push(features[i].geometry.coordinates);\n    }\n    poly.properties = features.reduce(function (aggregatedProperties, newFeature) {\n        for (var key in newFeature.properties) {\n            if (!aggregatedProperties[key]) {\n                aggregatedProperties[key] = [];\n            }\n            aggregatedProperties[key].push(newFeature.properties[key]);\n        }\n        return aggregatedProperties;\n    }, {});\n    return {\n        type: 'FeatureCollection',\n        features: [poly]\n    };\n}\n\nmodule.exports = {\n    isLon: isLon,\n    isLat: isLat,\n    guessLatHeader: guessLatHeader,\n    guessLonHeader: guessLonHeader,\n    csv: dsv.csvParse,\n    tsv: dsv.tsvParse,\n    dsv: dsv,\n    auto: auto,\n    csv2geojson: csv2geojson,\n    toLine: toLine,\n    toPolygon: toPolygon\n};\n"]},"metadata":{},"sourceType":"script"}