{"ast":null,"code":"function objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function (name, i) {\n    return JSON.stringify(name) + \": d[\" + i + \"]\";\n  }).join(\",\") + \"}\");\n}\n\nfunction customConverter(columns, f) {\n  var object = objectConverter(columns);\n  return function (row, i) {\n    return f(object(row), i, columns);\n  };\n} // Compute unique columns in order of discovery.\n\n\nfunction inferColumns(rows) {\n  var columnSet = Object.create(null),\n      columns = [];\n  rows.forEach(function (row) {\n    for (var column in row) {\n      if (!(column in columnSet)) {\n        columns.push(columnSet[column] = column);\n      }\n    }\n  });\n  return columns;\n}\n\nexport default function (delimiter) {\n  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n]\"),\n      delimiterCode = delimiter.charCodeAt(0);\n\n  function parse(text, f) {\n    var convert,\n        columns,\n        rows = parseRows(text, function (row, i) {\n      if (convert) return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns;\n    return rows;\n  }\n\n  function parseRows(text, f) {\n    var EOL = {},\n        // sentinel value for end-of-line\n    EOF = {},\n        // sentinel value for end-of-file\n    rows = [],\n        // output rows\n    N = text.length,\n        I = 0,\n        // current character index\n    n = 0,\n        // the current line number\n    t,\n        // the current token\n    eol; // is the current token followed by EOL?\n\n    function token() {\n      if (I >= N) return EOF; // special case: end of file\n\n      if (eol) return eol = false, EOL; // special case: end of line\n      // special case: quotes\n\n      var j = I,\n          c;\n\n      if (text.charCodeAt(j) === 34) {\n        var i = j;\n\n        while (i++ < N) {\n          if (text.charCodeAt(i) === 34) {\n            if (text.charCodeAt(i + 1) !== 34) break;\n            ++i;\n          }\n        }\n\n        I = i + 2;\n        c = text.charCodeAt(i + 1);\n\n        if (c === 13) {\n          eol = true;\n          if (text.charCodeAt(i + 2) === 10) ++I;\n        } else if (c === 10) {\n          eol = true;\n        }\n\n        return text.slice(j + 1, i).replace(/\"\"/g, \"\\\"\");\n      } // common case: find next delimiter or newline\n\n\n      while (I < N) {\n        var k = 1;\n        c = text.charCodeAt(I++);\n        if (c === 10) eol = true; // \\n\n        else if (c === 13) {\n            eol = true;\n            if (text.charCodeAt(I) === 10) ++I, ++k;\n          } // \\r|\\r\\n\n          else if (c !== delimiterCode) continue;\n        return text.slice(j, I - k);\n      } // special case: last token before EOF\n\n\n      return text.slice(j);\n    }\n\n    while ((t = token()) !== EOF) {\n      var a = [];\n\n      while (t !== EOL && t !== EOF) {\n        a.push(t);\n        t = token();\n      }\n\n      if (f && (a = f(a, n++)) == null) continue;\n      rows.push(a);\n    }\n\n    return rows;\n  }\n\n  function format(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function (row) {\n      return columns.map(function (column) {\n        return formatValue(row[column]);\n      }).join(delimiter);\n    })).join(\"\\n\");\n  }\n\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n\n  function formatValue(text) {\n    return text == null ? \"\" : reFormat.test(text += \"\") ? \"\\\"\" + text.replace(/\\\"/g, \"\\\"\\\"\") + \"\\\"\" : text;\n  }\n\n  return {\n    parse: parse,\n    parseRows: parseRows,\n    format: format,\n    formatRows: formatRows\n  };\n}","map":{"version":3,"sources":["C:/mapboxAndReact/node_modules/d3-dsv/src/dsv.js"],"names":["objectConverter","columns","Function","map","name","i","JSON","stringify","join","customConverter","f","object","row","inferColumns","rows","columnSet","Object","create","forEach","column","push","delimiter","reFormat","RegExp","delimiterCode","charCodeAt","parse","text","convert","parseRows","EOL","EOF","N","length","I","n","t","eol","token","j","c","slice","replace","k","a","format","formatValue","concat","formatRows","formatRow","test"],"mappings":"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","sourcesContent":["function objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n    return JSON.stringify(name) + \": d[\" + i + \"]\";\n  }).join(\",\") + \"}\");\n}\n\nfunction customConverter(columns, f) {\n  var object = objectConverter(columns);\n  return function(row, i) {\n    return f(object(row), i, columns);\n  };\n}\n\n// Compute unique columns in order of discovery.\nfunction inferColumns(rows) {\n  var columnSet = Object.create(null),\n      columns = [];\n\n  rows.forEach(function(row) {\n    for (var column in row) {\n      if (!(column in columnSet)) {\n        columns.push(columnSet[column] = column);\n      }\n    }\n  });\n\n  return columns;\n}\n\nexport default function(delimiter) {\n  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n]\"),\n      delimiterCode = delimiter.charCodeAt(0);\n\n  function parse(text, f) {\n    var convert, columns, rows = parseRows(text, function(row, i) {\n      if (convert) return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns;\n    return rows;\n  }\n\n  function parseRows(text, f) {\n    var EOL = {}, // sentinel value for end-of-line\n        EOF = {}, // sentinel value for end-of-file\n        rows = [], // output rows\n        N = text.length,\n        I = 0, // current character index\n        n = 0, // the current line number\n        t, // the current token\n        eol; // is the current token followed by EOL?\n\n    function token() {\n      if (I >= N) return EOF; // special case: end of file\n      if (eol) return eol = false, EOL; // special case: end of line\n\n      // special case: quotes\n      var j = I, c;\n      if (text.charCodeAt(j) === 34) {\n        var i = j;\n        while (i++ < N) {\n          if (text.charCodeAt(i) === 34) {\n            if (text.charCodeAt(i + 1) !== 34) break;\n            ++i;\n          }\n        }\n        I = i + 2;\n        c = text.charCodeAt(i + 1);\n        if (c === 13) {\n          eol = true;\n          if (text.charCodeAt(i + 2) === 10) ++I;\n        } else if (c === 10) {\n          eol = true;\n        }\n        return text.slice(j + 1, i).replace(/\"\"/g, \"\\\"\");\n      }\n\n      // common case: find next delimiter or newline\n      while (I < N) {\n        var k = 1;\n        c = text.charCodeAt(I++);\n        if (c === 10) eol = true; // \\n\n        else if (c === 13) { eol = true; if (text.charCodeAt(I) === 10) ++I, ++k; } // \\r|\\r\\n\n        else if (c !== delimiterCode) continue;\n        return text.slice(j, I - k);\n      }\n\n      // special case: last token before EOF\n      return text.slice(j);\n    }\n\n    while ((t = token()) !== EOF) {\n      var a = [];\n      while (t !== EOL && t !== EOF) {\n        a.push(t);\n        t = token();\n      }\n      if (f && (a = f(a, n++)) == null) continue;\n      rows.push(a);\n    }\n\n    return rows;\n  }\n\n  function format(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {\n      return columns.map(function(column) {\n        return formatValue(row[column]);\n      }).join(delimiter);\n    })).join(\"\\n\");\n  }\n\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n\n  function formatValue(text) {\n    return text == null ? \"\"\n        : reFormat.test(text += \"\") ? \"\\\"\" + text.replace(/\\\"/g, \"\\\"\\\"\") + \"\\\"\"\n        : text;\n  }\n\n  return {\n    parse: parse,\n    parseRows: parseRows,\n    format: format,\n    formatRows: formatRows\n  };\n}\n"]},"metadata":{},"sourceType":"module"}