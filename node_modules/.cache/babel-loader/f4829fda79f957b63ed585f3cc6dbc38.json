{"ast":null,"code":"/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant');\n\nvar ReactCurrentOwner = require('./ReactCurrentOwner');\n\nvar REACT_ELEMENT_TYPE = require('./ReactElementSymbol');\n\nvar getIteratorFn = require('./getIteratorFn');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar KeyEscapeUtils = require('./KeyEscapeUtils');\n\nvar warning = require('fbjs/lib/warning');\n\nvar SEPARATOR = '.';\nvar SUBSEPARATOR = ':';\n/**\r\n * This is inlined from ReactElement since this file is shared between\r\n * isomorphic and renderers. We could extract this to a\r\n *\r\n */\n\n/**\r\n * TODO: Test that a single child and an array with one item have the same key\r\n * pattern.\r\n */\n\nvar didWarnAboutMaps = false;\n/**\r\n * Generate a key string that identifies a component within a set.\r\n *\r\n * @param {*} component A component that could contain a manual key.\r\n * @param {number} index Index that is used if a manual key is not provided.\r\n * @return {string}\r\n */\n\nfunction getComponentKey(component, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (component && typeof component === 'object' && component.key != null) {\n    // Explicit key\n    return KeyEscapeUtils.escape(component.key);\n  } // Implicit key determined by the index in the set\n\n\n  return index.toString(36);\n}\n/**\r\n * @param {?*} children Children tree container.\r\n * @param {!string} nameSoFar Name of the key path so far.\r\n * @param {!function} callback Callback to invoke with each child found.\r\n * @param {?*} traverseContext Used to pass information throughout the traversal\r\n * process.\r\n * @return {!number} The number of children in this subtree.\r\n */\n\n\nfunction traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {\n  var type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  if (children === null || type === 'string' || type === 'number' || // The following is inlined from ReactElement. This means we can optimize\n  // some checks. React Fiber also inlines this logic for similar purposes.\n  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {\n    callback(traverseContext, children, // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows.\n    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);\n    return 1;\n  }\n\n  var child;\n  var nextName;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n\n  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getComponentKey(child, i);\n      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n    }\n  } else {\n    var iteratorFn = getIteratorFn(children);\n\n    if (iteratorFn) {\n      var iterator = iteratorFn.call(children);\n      var step;\n\n      if (iteratorFn !== children.entries) {\n        var ii = 0;\n\n        while (!(step = iterator.next()).done) {\n          child = step.value;\n          nextName = nextNamePrefix + getComponentKey(child, ii++);\n          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n        }\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          var mapsAsChildrenAddendum = '';\n\n          if (ReactCurrentOwner.current) {\n            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();\n\n            if (mapsAsChildrenOwnerName) {\n              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';\n            }\n          }\n\n          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;\n          didWarnAboutMaps = true;\n        } // Iterator will provide entry [k,v] tuples rather than values.\n\n\n        while (!(step = iterator.next()).done) {\n          var entry = step.value;\n\n          if (entry) {\n            child = entry[1];\n            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);\n            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n          }\n        }\n      }\n    } else if (type === 'object') {\n      var addendum = '';\n\n      if (process.env.NODE_ENV !== 'production') {\n        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';\n\n        if (children._isReactElement) {\n          addendum = \" It looks like you're using an element created by a different \" + 'version of React. Make sure to use only one copy of React.';\n        }\n\n        if (ReactCurrentOwner.current) {\n          var name = ReactCurrentOwner.current.getName();\n\n          if (name) {\n            addendum += ' Check the render method of `' + name + '`.';\n          }\n        }\n      }\n\n      var childrenString = String(children);\n      !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;\n    }\n  }\n\n  return subtreeCount;\n}\n/**\r\n * Traverses children that are typically specified as `props.children`, but\r\n * might also be specified through attributes:\r\n *\r\n * - `traverseAllChildren(this.props.children, ...)`\r\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\r\n *\r\n * The `traverseContext` is an optional argument that is passed through the\r\n * entire traversal. It can be used to store accumulations or anything else that\r\n * the callback might find relevant.\r\n *\r\n * @param {?*} children Children tree object.\r\n * @param {!function} callback To invoke upon traversing each child.\r\n * @param {?*} traverseContext Context for traversal.\r\n * @return {!number} The number of children in this subtree.\r\n */\n\n\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', callback, traverseContext);\n}\n\nmodule.exports = traverseAllChildren;","map":{"version":3,"sources":["C:/inhoiproject/node_modules/material-icons-react/node_modules/react/lib/traverseAllChildren.js"],"names":["_prodInvariant","require","ReactCurrentOwner","REACT_ELEMENT_TYPE","getIteratorFn","invariant","KeyEscapeUtils","warning","SEPARATOR","SUBSEPARATOR","didWarnAboutMaps","getComponentKey","component","index","key","escape","toString","traverseAllChildrenImpl","children","nameSoFar","callback","traverseContext","type","$$typeof","child","nextName","subtreeCount","nextNamePrefix","Array","isArray","i","length","iteratorFn","iterator","call","step","entries","ii","next","done","value","process","env","NODE_ENV","mapsAsChildrenAddendum","current","mapsAsChildrenOwnerName","getName","entry","addendum","_isReactElement","name","childrenString","String","Object","keys","join","traverseAllChildren","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n\r\n'use strict';\r\n\r\nvar _prodInvariant = require('./reactProdInvariant');\r\n\r\nvar ReactCurrentOwner = require('./ReactCurrentOwner');\r\nvar REACT_ELEMENT_TYPE = require('./ReactElementSymbol');\r\n\r\nvar getIteratorFn = require('./getIteratorFn');\r\nvar invariant = require('fbjs/lib/invariant');\r\nvar KeyEscapeUtils = require('./KeyEscapeUtils');\r\nvar warning = require('fbjs/lib/warning');\r\n\r\nvar SEPARATOR = '.';\r\nvar SUBSEPARATOR = ':';\r\n\r\n/**\r\n * This is inlined from ReactElement since this file is shared between\r\n * isomorphic and renderers. We could extract this to a\r\n *\r\n */\r\n\r\n/**\r\n * TODO: Test that a single child and an array with one item have the same key\r\n * pattern.\r\n */\r\n\r\nvar didWarnAboutMaps = false;\r\n\r\n/**\r\n * Generate a key string that identifies a component within a set.\r\n *\r\n * @param {*} component A component that could contain a manual key.\r\n * @param {number} index Index that is used if a manual key is not provided.\r\n * @return {string}\r\n */\r\nfunction getComponentKey(component, index) {\r\n  // Do some typechecking here since we call this blindly. We want to ensure\r\n  // that we don't block potential future ES APIs.\r\n  if (component && typeof component === 'object' && component.key != null) {\r\n    // Explicit key\r\n    return KeyEscapeUtils.escape(component.key);\r\n  }\r\n  // Implicit key determined by the index in the set\r\n  return index.toString(36);\r\n}\r\n\r\n/**\r\n * @param {?*} children Children tree container.\r\n * @param {!string} nameSoFar Name of the key path so far.\r\n * @param {!function} callback Callback to invoke with each child found.\r\n * @param {?*} traverseContext Used to pass information throughout the traversal\r\n * process.\r\n * @return {!number} The number of children in this subtree.\r\n */\r\nfunction traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {\r\n  var type = typeof children;\r\n\r\n  if (type === 'undefined' || type === 'boolean') {\r\n    // All of the above are perceived as null.\r\n    children = null;\r\n  }\r\n\r\n  if (children === null || type === 'string' || type === 'number' ||\r\n  // The following is inlined from ReactElement. This means we can optimize\r\n  // some checks. React Fiber also inlines this logic for similar purposes.\r\n  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {\r\n    callback(traverseContext, children,\r\n    // If it's the only child, treat the name as if it was wrapped in an array\r\n    // so that it's consistent if the number of children grows.\r\n    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);\r\n    return 1;\r\n  }\r\n\r\n  var child;\r\n  var nextName;\r\n  var subtreeCount = 0; // Count of children found in the current subtree.\r\n  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\r\n\r\n  if (Array.isArray(children)) {\r\n    for (var i = 0; i < children.length; i++) {\r\n      child = children[i];\r\n      nextName = nextNamePrefix + getComponentKey(child, i);\r\n      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\r\n    }\r\n  } else {\r\n    var iteratorFn = getIteratorFn(children);\r\n    if (iteratorFn) {\r\n      var iterator = iteratorFn.call(children);\r\n      var step;\r\n      if (iteratorFn !== children.entries) {\r\n        var ii = 0;\r\n        while (!(step = iterator.next()).done) {\r\n          child = step.value;\r\n          nextName = nextNamePrefix + getComponentKey(child, ii++);\r\n          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\r\n        }\r\n      } else {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n          var mapsAsChildrenAddendum = '';\r\n          if (ReactCurrentOwner.current) {\r\n            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();\r\n            if (mapsAsChildrenOwnerName) {\r\n              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';\r\n            }\r\n          }\r\n          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;\r\n          didWarnAboutMaps = true;\r\n        }\r\n        // Iterator will provide entry [k,v] tuples rather than values.\r\n        while (!(step = iterator.next()).done) {\r\n          var entry = step.value;\r\n          if (entry) {\r\n            child = entry[1];\r\n            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);\r\n            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\r\n          }\r\n        }\r\n      }\r\n    } else if (type === 'object') {\r\n      var addendum = '';\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';\r\n        if (children._isReactElement) {\r\n          addendum = \" It looks like you're using an element created by a different \" + 'version of React. Make sure to use only one copy of React.';\r\n        }\r\n        if (ReactCurrentOwner.current) {\r\n          var name = ReactCurrentOwner.current.getName();\r\n          if (name) {\r\n            addendum += ' Check the render method of `' + name + '`.';\r\n          }\r\n        }\r\n      }\r\n      var childrenString = String(children);\r\n      !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;\r\n    }\r\n  }\r\n\r\n  return subtreeCount;\r\n}\r\n\r\n/**\r\n * Traverses children that are typically specified as `props.children`, but\r\n * might also be specified through attributes:\r\n *\r\n * - `traverseAllChildren(this.props.children, ...)`\r\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\r\n *\r\n * The `traverseContext` is an optional argument that is passed through the\r\n * entire traversal. It can be used to store accumulations or anything else that\r\n * the callback might find relevant.\r\n *\r\n * @param {?*} children Children tree object.\r\n * @param {!function} callback To invoke upon traversing each child.\r\n * @param {?*} traverseContext Context for traversal.\r\n * @return {!number} The number of children in this subtree.\r\n */\r\nfunction traverseAllChildren(children, callback, traverseContext) {\r\n  if (children == null) {\r\n    return 0;\r\n  }\r\n\r\n  return traverseAllChildrenImpl(children, '', callback, traverseContext);\r\n}\r\n\r\nmodule.exports = traverseAllChildren;"]},"metadata":{},"sourceType":"script"}